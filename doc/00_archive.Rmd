---
title: "Impact of dysfunctional ubiquitination in response to cancer immunotherapy"
subtitle: <center> Archive code </center>
author: "Eric Bautista Farrerons (s212514)"
date: '`r paste("First created on January 2024. Updated on ", format(Sys.Date(), "%d %B %Y"))`'
output:
  html_document:
    css: style.css
    code_folding: hide
    fig_caption: yes
    toc: yes
    toc_float:
      collapsed: true
      smooth_scroll: true
    toc_depth: 4
    number_sections: true
---

```{r, message=FALSE}
### Load required libraries
library(readxl)
library(tidyverse)
library(dplyr)
library(knitr)
library(DT)
library(httr)
library(jsonlite)
library(VariantAnnotation)

### Load functions
source(file = "../R/02_functions.R")

### Define paths
current_dir <- getwd()

# MAF-like file
maf_data <- "../data/_raw/41467_2017_1460_MOESM6_ESM_somatic_mutations.xlsx"
maf_path <- file.path(current_dir, 
                      maf_data)

### Read data
maf_df <- read_excel(maf_path,
                        skip=1,
                        col_names=TRUE)
```

## See mutations per patient

```{r}
unique_tumor_counts <- maf_df %>%
count(tumor_name, 
      sort = TRUE)  # Count unique values and sort

# Display the result
datatable(unique_tumor_counts, 
          extensions = 'Buttons', 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "Mutation counts per patient"
        )
```

## Pre-processing

```{r, warning=FALSE}
# Filter rows where Entrez_Gene_Id is 0
missing_entrez_df <- maf_df %>%
  filter(Entrez_Gene_Id == 0)

# Filter rows where Hugo_Symbol is Unknown
missing_hugo_df <- maf_df %>%
  filter(Hugo_Symbol == 'Unknown')

n_rows_1 <- nrow(missing_entrez_df)
n_rows_2 <- nrow(missing_hugo_df)

print(paste("Number of samples missing an Entrez ID:", n_rows_1))
print(paste("Number of samples missing Hugo Symbol:", n_rows_2))
```

## Export info to use Ensembl VEP (web version)

```{r}
### Extract info in correct format for VEP input
api_input <- maf_df %>% 
  select(Chromosome,
         Start_position,
         End_position,
         ref_allele,
         alt_allele,
         Strand) %>% 
  mutate(Allele_ref_alt = paste(ref_allele, 
                                alt_allele, 
                                sep = "/")) %>% 
  mutate(API_info = paste(Chromosome,
                          Start_position,
                          End_position,
                          Allele_ref_alt,
                          Strand,
                          sep = " "))
```

## Misc

```{r}
###### Only 200 input POST API request

# Assuming api_input is your dataframe and API_info is the column with variant information
variant_info <- api_input[1200:1399,]$API_info

# Convert the vector of variants into JSON
json_data <- toJSON(list(variants = variant_info))

# API URL (ensure the URL is correct and includes the necessary protocol, such as https)
url <- "https://grch37.rest.ensembl.org/vep/homo_sapiens/region"

# Set headers for POST request
headers <- c("Content-Type" = "application/json", "Accept" = "application/json")

# Send the POST request
mock_response <- POST(url, body = json_data, add_headers(.headers=headers))

# Check if the request was successful
if (status_code(mock_response) == 200) {
  # Parse the JSON response
  mock_results <- content(mock_response, "parsed", simplifyVector = TRUE)

  # Convert results to a data frame or manipulate as needed
  mock_results_df <- as.data.frame(mock_results)
} else {
  print(paste("Error:", status_code(mock_response)))
}

mock_results_df
```

```{r}
# Function to split the dataframe into smaller chunks
split_data <- function(df, chunk_size) {
  split_indices <- ceiling(seq_len(nrow(df)) / chunk_size)
  split(df, split_indices)
}

# Split api_input into chunks of 200 rows
chunks <- split_data(api_input, 200)

# Initialize an empty list to store results from each chunk
all_results <- list()

# API URL (use GRCh37)
url <- "https://grch37.rest.ensembl.org/vep/homo_sapiens/region"

# Set headers for POST request
headers <- c("Content-Type" = "application/json", "Accept" = "application/json")

# Function to process each chunk
process_chunk <- function(chunk) {
  
  # Convert the list of variants into JSON
  json_data <- toJSON(list(variants = chunk$API_info))
  
  # Send the POST request
  response <- POST(url, body = json_data, add_headers(.headers=headers))
  
  # Check if the request was successful
  if (status_code(response) == 200) {
    
    # Parse the JSON response
    content(response, "parsed", simplifyVector = TRUE)
  
    } else {
    warning(paste("Error on chunk:", status_code(response)))
    NULL
  }
}

# Iterate over each chunk, process it, and store the results
for (i in seq_along(chunks)) {
  cat("Processing chunk", i, "out of", length(chunks), "\n")
  results <- process_chunk(chunks[[i]])
  if (!is.null(results)) {
    all_results[[i]] <- results
  }
}

# Combine all results into a single data frame
results_df <- bind_rows(all_results)
```

```{r}
# Check if 'transcript_consequences' column exists and unnest it
if ("transcript_consequences" %in% colnames(results_df)) {
  results_df <- results_df %>%
    unnest(transcript_consequences,
           names_sep = "_")
}

# Check if 'intergenic_consequences' column exists and unnest it
if ("intergenic_consequences" %in% colnames(results_df)) {
  results_df <- results_df %>%
    unnest(intergenic_consequences,
           names_sep = "_")
}
```

```{r}
# Initialize an empty list to store the resulting data frames
result_dfs <- list()

# Iterate over each column in results_df
for (col_name in colnames(results_df)) {
  # Check if the column contains list-type objects
  if (any(sapply(results_df[[col_name]], is.list))) {
    # Unnest the column and store the resulting data frame in the list
    results_df <- results_df %>%
      unnest(col_name, 
             names_sep = "_")
  }
}
```

```{r}
datatable(results_df, 
          extensions = 'Buttons', 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "VEP result"
        )
```

```{r}
conseq_df <- as.data.frame(results_df[1]$transcript_consequences)
datatable(conseq_df, 
          extensions = 'Buttons', 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "Transcript consequences"
        )
```



## Session Info

```{r}
sessionInfo()
```
