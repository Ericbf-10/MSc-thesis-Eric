---
title: "Impact of dysfunctional ubiquitination in response to cancer immunotherapy"
subtitle: <center> Archive code </center>
author: "Eric Bautista Farrerons (s212514)"
date: '`r paste("First created on January 2024. Updated on ", format(Sys.Date(), "%d %B %Y"))`'
output:
  html_document:
    css: style.css
    code_folding: hide
    fig_caption: yes
    toc: yes
    toc_float:
      collapsed: true
      smooth_scroll: true
    toc_depth: 4
    number_sections: true
---

```{r, message=FALSE}
### Load required libraries
library(readxl)
library(tidyverse)
library(dplyr)
library(knitr)
library(DT)
library(httr)
library(jsonlite)
library(VariantAnnotation)

### Load functions
source(file = "../02_functions.R")

### Define paths
current_dir <- getwd()

# MAF-like file
maf_data <- "../../data/_raw/41467_2017_1460_MOESM6_ESM_somatic_mutations.xlsx"
maf_path <- file.path(current_dir, 
                      maf_data)

### Read data
maf_df <- read_excel(maf_path,
                        skip=1,
                        col_names=TRUE)
```

## See mutations per patient

```{r}
unique_tumor_counts <- maf_df %>%
count(tumor_name, 
      sort = TRUE)  # Count unique values and sort

# Display the result
datatable(unique_tumor_counts, 
          extensions = 'Buttons', 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "Mutation counts per patient"
        )
```

## Pre-processing

```{r, warning=FALSE}
# Filter rows where Entrez_Gene_Id is 0
missing_entrez_df <- maf_df %>%
  filter(Entrez_Gene_Id == 0)

# Filter rows where Hugo_Symbol is Unknown
missing_hugo_df <- maf_df %>%
  filter(Hugo_Symbol == 'Unknown')

n_rows_1 <- nrow(missing_entrez_df)
n_rows_2 <- nrow(missing_hugo_df)

print(paste("Number of samples missing an Entrez ID:", n_rows_1))
print(paste("Number of samples missing Hugo Symbol:", n_rows_2))
```

## Export info to use Ensembl VEP (web version)

```{r}
### Extract info in correct format for VEP input
api_input <- maf_df %>% 
  select(Chromosome,
         Start_position,
         End_position,
         ref_allele,
         alt_allele,
         Strand) %>% 
  mutate(Allele_ref_alt = paste(ref_allele, 
                                alt_allele, 
                                sep = "/")) %>% 
  mutate(API_info = paste(Chromosome,
                          Start_position,
                          End_position,
                          Allele_ref_alt,
                          Strand,
                          sep = " "))
```

## Misc

```{r}
###### Only 200 input POST API request

# Assuming api_input is your dataframe and API_info is the column with variant information
variant_info <- api_input[1200:1399,]$API_info

# Convert the vector of variants into JSON
json_data <- toJSON(list(variants = variant_info))

# API URL (ensure the URL is correct and includes the necessary protocol, such as https)
url <- "https://grch37.rest.ensembl.org/vep/homo_sapiens/region"

# Set headers for POST request
headers <- c("Content-Type" = "application/json", "Accept" = "application/json")

# Send the POST request
mock_response <- POST(url, body = json_data, add_headers(.headers=headers))

# Check if the request was successful
if (status_code(mock_response) == 200) {
  # Parse the JSON response
  mock_results <- content(mock_response, "parsed", simplifyVector = TRUE)

  # Convert results to a data frame or manipulate as needed
  mock_results_df <- as.data.frame(mock_results)
} else {
  print(paste("Error:", status_code(mock_response)))
}

mock_results_df
```

```{r}
# Function to split the dataframe into smaller chunks
split_data <- function(df, chunk_size) {
  split_indices <- ceiling(seq_len(nrow(df)) / chunk_size)
  split(df, split_indices)
}

# Split api_input into chunks of 200 rows
chunks <- split_data(api_input, 200)

# Initialize an empty list to store results from each chunk
all_results <- list()

# API URL (use GRCh37)
url <- "https://grch37.rest.ensembl.org/vep/homo_sapiens/region"

# Set headers for POST request
headers <- c("Content-Type" = "application/json", "Accept" = "application/json")

# Function to process each chunk
process_chunk <- function(chunk) {
  
  # Convert the list of variants into JSON
  json_data <- toJSON(list(variants = chunk$API_info))
  
  # Send the POST request
  response <- POST(url, body = json_data, add_headers(.headers=headers))
  
  # Check if the request was successful
  if (status_code(response) == 200) {
    
    # Parse the JSON response
    content(response, "parsed", simplifyVector = TRUE)
  
    } else {
    warning(paste("Error on chunk:", status_code(response)))
    NULL
  }
}

# Iterate over each chunk, process it, and store the results
for (i in seq_along(chunks)) {
  cat("Processing chunk", i, "out of", length(chunks), "\n")
  results <- process_chunk(chunks[[i]])
  if (!is.null(results)) {
    all_results[[i]] <- results
  }
}

# Combine all results into a single data frame
results_df <- bind_rows(all_results)
```

```{r}
# Check if 'transcript_consequences' column exists and unnest it
if ("transcript_consequences" %in% colnames(results_df)) {
  results_df <- results_df %>%
    unnest(transcript_consequences,
           names_sep = "_")
}

# Check if 'intergenic_consequences' column exists and unnest it
if ("intergenic_consequences" %in% colnames(results_df)) {
  results_df <- results_df %>%
    unnest(intergenic_consequences,
           names_sep = "_")
}
```

```{r}
# Initialize an empty list to store the resulting data frames
result_dfs <- list()

# Iterate over each column in results_df
for (col_name in colnames(results_df)) {
  # Check if the column contains list-type objects
  if (any(sapply(results_df[[col_name]], is.list))) {
    # Unnest the column and store the resulting data frame in the list
    results_df <- results_df %>%
      unnest(col_name, 
             names_sep = "_")
  }
}
```

```{r}
datatable(results_df, 
          extensions = 'Buttons', 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "VEP result"
        )
```

```{r}
conseq_df <- as.data.frame(results_df[1]$transcript_consequences)
datatable(conseq_df, 
          extensions = 'Buttons', 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "Transcript consequences"
        )
```

## Get the Hugo Symbols & Ensembl Gene IDs from Entrez IDs

```{r}
# Connect to the Ensembl BioMart database
ensembl = biomaRt::useMart(biomart="ENSEMBL_MART_ENSEMBL", 
                  host="https://grch37.ensembl.org", 
                  path="/biomart/martservice",
                  dataset="hsapiens_gene_ensembl")

# Extracting non-NA and non-zero values and ensuring they are unique
entrez_ids <- unique(na.omit(maf_df$Entrez_Gene_Id[maf_df$Entrez_Gene_Id != 0]))

# Ensure that entrez_ids is a character vector
entrez_ids <- as.character(entrez_ids)

# Retrieve Hugo symbols & Ensembl gene ids
reannotated_df <- biomaRt::getBM(attributes = c("entrezgene_id", 
                                                "hgnc_symbol", 
                                                "ensembl_gene_id"),
                   filters = "entrezgene_id",
                   values = entrez_ids,
                   mart = ensembl)

# Rename columns so that they match maf_df
# reannotated_df <- reannotated_df %>%
#   dplyr::rename(
#     Entrez_Gene_Id = entrezgene_id,
#     Ensembl_Gene_Id = ensembl_gene_id
#   )

# Left join reannotated_df with maf_df
maf_df_updated <- maf_df %>%
  left_join(reannotated_df, by = c("Entrez_Gene_Id" = "entrezgene_id"))

# View the updated dataframe
DT::datatable(maf_df_updated, 
          extensions = c('Buttons'),
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "MAF_df reannotated"
        )
```

```{r}
# Count the number of unique values in the ensembl_gene_id column
num_unique_values <- reannotated_df %>% 
  summarise(unique_count = n_distinct(entrezgene_id)) %>% 
  pull(unique_count)

# Print the number of unique values
print(paste("Number of unique Entrez Gene IDs in reannotated_df:", num_unique_values))

# Search for a particular Entrez_Gene_Id
reannotated_df %>% 
  filter(entrezgene_id == "100526835")
```

## DEBUG: explore unique values in columns

```{r}
vep_df_clean %>% 
  dplyr::count(MPC) %>%  
  arrange(desc(n))
```

```{r}
maf_df %>%
  group_by(sample_id, Entrez_Gene_Id, Codon_Change)
```

```{r}
maf_df_annotated %>%
  group_by(sample_id, Codon_Change, Ensembl_gene_id)
```

```{r}
maf_df_rowid <- maf_df %>%
  dplyr::mutate(ori_row_id = row_number(),
                temp_row_id = row_number())

# Assuming 'Exclude_Column' is the column you want to keep but exclude from the distinct check
# First, save the excluded column temporarily
temp_excluded_column <- maf_df_rowid %>%
  dplyr::select(row_id)

# Then, perform distinct operation without the excluded column
maf_df_distinct <- maf_df_rowid %>%
  dplyr::select(-row_id) %>%
  dplyr::distinct()

# Now, bind the temporarily saved column back row-wise (assuming the order hasn't been changed)
maf_df_distinct <- bind_cols(maf_df_distinct, temp_excluded_column)
```

```{r}
unique_maf_df <- maf_df %>%
  dplyr::distinct()

removed_rows <- dplyr::anti_join(maf_df,
                                unique_maf_df)

print(nrow(removed_rows))
```

```{r}
unique_maf_df_annotated <- maf_df_annotated %>%
  dplyr::distinct()

removed_rows <- dplyr::anti_join(maf_df_annotated,
                                unique_maf_df_annotated)

print(nrow(removed_rows))
```

```{r}
maf_df_annotated_wo_ensembl <- maf_df_annotated %>%
  dplyr::select(-Ensembl_gene_id)

# Identify unique rows based on specified columns
unique_rows <- maf_df_annotated_wo_ensembl %>%
  dplyr::distinct()

# Find rows in the original dataframe not present in the unique set (i.e., removed rows)
removed_rows <- dplyr::anti_join(maf_df_annotated_wo_ensembl,
                                         unique_rows)
print(nrow(removed_rows))
```

```{r}
list_of_drugs <- c("Vemurafenib (BRAFi)", "Dacarbazine", "Ipilimumab", "Binimetinib (MEKi) - after", "Nivolumab - after", "Pembroluzimab - after", "Selinexor - after", "Temodal", "IL-2")
```

## Session Info

```{r}
sessionInfo()
```
