---
title: "Impact of dysfunctional ubiquitination in response to cancer immunotherapy"
subtitle: <center> Somatic mutations analysis - Ubiquitin custom Gene Sets </center>
author: "Eric Bautista Farrerons (s212514)"
date: '`r paste("First created on March 2024. Updated on ", format(Sys.Date(), "%d %B %Y"))`'
output:
  html_document:
    css: style.css
    code_folding: hide
    fig_caption: yes
    toc: yes
    toc_float:
      collapsed: true
      smooth_scroll: true
    toc_depth: 4
    number_sections: true
---

# Load data

```{r, message=FALSE}
### Load required libraries
library(readxl)
library(tidyverse)
library(purrr)
library(dplyr)
library(knitr)
library(DT)
library(httr)
library(jsonlite)
library(stringr)
library(GSEABase)
library(HGNChelper)
library(mygene)
library(GO.db)
library(AnnotationDbi)

### Load functions
source(file = "../02_functions.R")

### Define paths
current_dir <- getwd()
data_path <- file.path(current_dir,
                       "../../data/_raw")
results_pc_path <- file.path(current_dir,
                              "../../results/patient_characteristics/output")
results_fip_path <- file.path(current_dir,
                              "../../results/somatic_mutation_analysis/functional_impact_prediction/output")
results_ubgenesets_path <- file.path(current_dir, 
                                 "../../results/somatic_mutation_analysis/ubiquitin_custom_GS/output")

# Create the folder if it does not exist
if(!file.exists(results_ubgenesets_path)) {
  dir.create(results_ubgenesets_path, recursive = TRUE)
}

figures_ubgenesets_path <- file.path(current_dir, 
                                 "../../results/somatic_mutation_analysis/ubiquitin_custom_GS/figures")

# Create the folder if it does not exist
if(!file.exists(figures_ubgenesets_path)) {
  dir.create(figures_ubgenesets_path, recursive = TRUE)
}

maf_df_path <- file.path(results_fip_path, "all_mutations.csv") # All mutations df
nonsyn_df_path <- file.path(results_fip_path, "nonsyn_mutations.csv") # Nonsyn mutations df
lof_df_path <- file.path(results_fip_path, "lof_mutations_reduced.csv") # LoF mutations df

# Sup1 data
sup1_response_path <- file.path(results_pc_path, 
                           "sup1_response.csv")
### Read data & wrangle

# Read 3 lists of mutations

# All
maf_df_annotated <- read.csv(maf_df_path, header = TRUE)[ , -1]
list_of_all_mutations <- split(maf_df_annotated, maf_df_annotated$sample_id
                               )
# Nonsyn
nonsyn_df_annotated <- read.csv(nonsyn_df_path, header = TRUE)[ , -1]
list_of_nonsyn_mutations <- split(nonsyn_df_annotated, nonsyn_df_annotated$sample_id)

# LoF
lof_df_annotated <- read.csv(lof_df_path, header = TRUE)[ , -1]
list_of_lof_mutations <- split(lof_df_annotated, lof_df_annotated$sample_id)

# Get the list of patient IDs
sample_id_list <- unique(maf_df_annotated$sample_id)

## Read sup1_response.csv
sup1_response_df <- read.csv(sup1_response_path)[ , -1] # Drop first column

# df to merge response info later
response_df <- sup1_response_df %>% 
  dplyr::rename(sample_id = Sample.ID,
                patient_response = Patient.Response) %>% 
  dplyr::select(sample_id, patient_response)

# Create a list of Responders and Non-responders
sample_id_lists <- split(sup1_response_df$Sample.ID, 
                         sup1_response_df$Patient.Response) # Split the "Sample.ID" values into lists based on "Patient.Response"

r_sample_ids <- sample_id_lists$R
nr_sample_ids <- sample_id_lists$NR
```

# Correcting Hugo Symbols in input data

```{r, message=FALSE, warning=FALSE}
# Load the GMT file
gene_sets_collection <- getGmt(file.path(data_path, "ubgenes.gmt"))

# Initialize an empty data frame for gene IDs
corrected_hsymbols <- data.frame()

# Extract gene sets and their descriptions
for (gene_set_id in names(gene_sets_collection)) {
  gene_set <- gene_sets_collection[[gene_set_id]]
  gene_ids <- geneIds(gene_set)
  
  # Replace "/" with "-" in gene IDs
  gene_ids <- gsub("/", "-", gene_ids)
  
  # Reverse date-like hugo symbols
  gene_ids <- correct_date_like_symbols(gene_ids)
  
  # Create a temporary data frame for this gene set
  temp_df <- checkGeneSymbols(gene_ids)
  
  # Combine with the main data frame
  corrected_hsymbols <- rbind(corrected_hsymbols, temp_df)
}

# Split the gene_id where "///" is found and keep only the second part (if exists)
corrected_hsymbols$Suggested.Symbol <- sapply(str_split(corrected_hsymbols$Suggested.Symbol, " /// "), function(x) {
  if (length(x) > 1) {
    # If there's more than one part, keep the second one
    return(trimws(x[2]))
  } else {
    # If there's only one part, keep it as is
    return(trimws(x[1]))
  }
})

corrected_hsymbols <- corrected_hsymbols %>% 
  dplyr::rename(c(hugo_symbol = x, 
                  corrected_hugo_symbol = Suggested.Symbol)) %>% 
  dplyr::select(hugo_symbol, corrected_hugo_symbol)
```

# Filtering lists to only include Ubiquitin-related genes

```{r, message=FALSE, warning=FALSE}
# Map HUGO symbols to Ensembl Gene IDs
corrected_hsymbols$ensembl_id <- SYMBOLtoENSEMBL(corrected_hsymbols$corrected_hugo_symbol)

# Check missing Ensembl IDs
missing_ensembl <- corrected_hsymbols %>% 
  dplyr::filter(!str_detect(ensembl_id, "^ENSG"))

# Find them manually and update df (for now only Ensembl Gene IDs)
missing_ensembl <- missing_ensembl %>%
  dplyr::mutate(
    # corrected_hugo_symbol = case_when(
  #   hugo_symbol == "UBE2L5" ~ "UBE2L5P",
  #   hugo_symbol == "BABAM2" ~ "BRE",
  #   hugo_symbol == "COP1" ~ "RFWD2",
  #   hugo_symbol == "DCAF1" ~ "VPRBP",
  #   hugo_symbol == "DMAC2" ~ "ATP5SL",
  #   hugo_symbol == "ELOB" ~ "TCEB2",
  #   hugo_symbol == "FBH1" ~ "FBXO18",
  #   hugo_symbol == "FBXL21P" ~ "FBXL21",
  #   hugo_symbol == "MARCHF6" ~ "MARCH6",
  #   hugo_symbol == "1-Mar" ~ "MARCH1",
  #   hugo_symbol == "10-Mar" ~ "MARCH10",
  #   hugo_symbol == "11-Mar" ~ "MARCH11",
  #   hugo_symbol == "2-Mar" ~ "MARCH2",
  #   hugo_symbol == "3-Mar" ~ "MARCH3",
  #   hugo_symbol == "4-Mar" ~ "MARCH4",
  #   hugo_symbol == "5-Mar" ~ "MARCH5",
  #   hugo_symbol == "6-Mar" ~ "MARCH6",
  #   hugo_symbol == "7-Mar" ~ "MARCH7",
  #   hugo_symbol == "8-Mar" ~ "MARCH8",
  #   hugo_symbol == "9-Mar" ~ "MARCH9",
  #   hugo_symbol == "PARK2" ~ "PARK2",
  #   hugo_symbol == "RFWD2" ~ "RFWD2",
  #   hugo_symbol == "RNF212B" ~ "C14orf164",
  #   hugo_symbol == "RNF219" ~ "RNF219",
  #   hugo_symbol == "RNF225" ~ "RNF225",
  #   hugo_symbol == "TRIM75P" ~ "TRIM75P",
  #   hugo_symbol == "ZNF645" ~ "ZNF645",
  #   hugo_symbol == "USP17L1" ~ "USP17L1P",
  #   hugo_symbol == "OTULIN" ~ "FAM105B",
  #   TRUE ~ corrected_hugo_symbol
  # ),
  ensembl_id = case_when(
    hugo_symbol == "UBE2L5" ~ "ENSG00000236444",
    hugo_symbol == "BABAM2" ~ "ENSG00000158019",
    hugo_symbol == "COP1" ~ "ENSG00000143207",
    hugo_symbol == "DCAF1" ~ "ENSG00000145041",
    hugo_symbol == "DMAC2" ~ "ENSG00000105341",
    hugo_symbol == "ELOB" ~ "ENSG00000103363",
    hugo_symbol == "FBH1" ~ "ENSG00000134452",
    hugo_symbol == "FBXL21P" ~ "ENSG00000164616",
    hugo_symbol == "MARCHF6" ~ "ENSG00000145495",
    hugo_symbol == "1-Mar" ~ "ENSG00000145416",
    hugo_symbol == "10-Mar" ~ "ENSG00000173838",
    hugo_symbol == "11-Mar" ~ "ENSG00000183654",
    hugo_symbol == "2-Mar" ~ "ENSG00000099785",
    hugo_symbol == "3-Mar" ~ "ENSG00000173926",
    hugo_symbol == "4-Mar" ~ "ENSG00000144583",
    hugo_symbol == "5-Mar" ~ "ENSG00000198060",
    hugo_symbol == "6-Mar" ~ "ENSG00000145495",
    hugo_symbol == "7-Mar" ~ "ENSG00000136536",
    hugo_symbol == "8-Mar" ~ "ENSG00000165406",
    hugo_symbol == "9-Mar" ~ "ENSG00000139266",
    hugo_symbol == "PARK2" ~ "ENSG00000185345",
    hugo_symbol == "RFWD2" ~ "ENSG00000143207",
    hugo_symbol == "RNF212B" ~ "ENSG00000215277",
    hugo_symbol == "RNF219" ~ "ENSG00000152193",
    hugo_symbol == "RNF225" ~ "ENSG00000269855",
    hugo_symbol == "TRIM75P" ~ "ENSG00000250374",
    hugo_symbol == "ZNF645" ~ "ENSG00000175809",
    hugo_symbol == "USP17L1" ~ "ENSG00000230549",
    hugo_symbol == "OTULIN" ~ "ENSG00000154124",
    TRUE ~ ensembl_id
  ))

# Merge the dataframes
corrected_hsymbols_updated <- corrected_hsymbols %>%
  left_join(dplyr::select(missing_ensembl, 
                          hugo_symbol, 
                          # new_corrected_hugo_symbol = corrected_hugo_symbol, 
                          new_ensembl_id = ensembl_id),
            by = "hugo_symbol")

# Update the values based on the join
corrected_hsymbols_updated <- corrected_hsymbols_updated %>%
  dplyr::mutate(
    # corrected_hugo_symbol = ifelse(!is.na(new_corrected_hugo_symbol), new_corrected_hugo_symbol, corrected_hugo_symbol),
    ensembl_id = ifelse(!is.na(new_ensembl_id), new_ensembl_id, ensembl_id)
    ) %>%
  dplyr::select(
    # -new_corrected_hugo_symbol, 
    -new_ensembl_id)

# Extract the ensembl_id column to do the filtering
ubiquitin_df <- corrected_hsymbols_updated %>% 
  dplyr::select(ensembl_id)

# Get ubiquitin unique ensembl ids
ub_ensembl_ids <- unique(corrected_hsymbols_updated$ensembl_id)

# Filter for ubiquitin genes in all the mutation lists
list_of_all_ub_mutations <- ubiquitin_filter(list_of_all_mutations, ubiquitin_df)
list_of_nonsyn_ub_mutations <- ubiquitin_filter(list_of_nonsyn_mutations, ubiquitin_df)
list_of_lof_ub_mutations <- ubiquitin_filter(list_of_lof_mutations, ubiquitin_df)

# Bind rows to re-generate the dataframes
all_df_ubiquitin <- bind_rows(list_of_all_ub_mutations)
nonsyn_df_ubiquitin <- bind_rows(list_of_nonsyn_ub_mutations)
lof_df_ubiquitin <- bind_rows(list_of_lof_ub_mutations)

# Get all unique sample_id values
unique_sample_ids <- unique(list_of_lof_ub_mutations$sample_id)
```

# Summary of mutations per patient

```{r, message=FALSE, warning=FALSE, fig.width=12, fig.height=12}
# Define output path
mm909_sum_plot_path <- file.path(figures_ubgenesets_path,
                              "mm909_sum_plot.png")

# Summary plot
mm909_sum_plot <- sum_plot(response_df, all_df_ubiquitin, nonsyn_df_ubiquitin, lof_df_ubiquitin, mm909_sum_plot_path)

# Display
print(mm909_sum_plot)
```

Sample MM909_47 does not have any Ubiquitin-related gene, and MM909_14, MM909_36 don't have any LoF on ubiquitin genes.

# Build a DB of GO terms for ubiquitin-related Bio Processes (based on gene list)

#### Define categories. Define which parent terms I want to use and get offspring.
#### Build the DB with Category > Parent > Children.
#### Get all GO.db ubiquitin terms.
#### Iterate through the ubiquitin terms from GO.db and annotate the parent terms. Make a data.frame.
#### Check the ones that have +1 GO parent term and reduce to 1.
#### Get Ensembl IDs related to those GO terms. 

```{r, message=FALSE, warning=FALSE}
#1 Define categories and parents

# Categories (as character)
ub_categories <- c("ubiquitination", "deubiquitination", "ubiquitin_independent")
# ub_categories <- setNames(as.list(ub_categories), ub_categories)

# Parents (as character)
ub_parent_terms <- c("GO:0016567", "GO:0016579", "GO:0006511", "GO:0010499", "GO:0010992", "GO:0070086", "GO:0120323", "GO:0031397", "GO:0031398", "GO:2000059", "GO:2000060") # "GO:0051438" --> removed because regulation can be positive or negative
# ub_parent_terms <- setNames(as.list(ub_parent_terms), ub_parent_terms)

# Children (as list)
all_offspring <- as.list(GOBPOFFSPRING) # Get the offspring terms
parent2child_list <- map(ub_parent_terms, function(x) {
  offspring <- all_offspring[[x]]
  # If offspring has elements, return it (with parent itself)
  if (length(offspring) > 1) {
    return(c(x, offspring))
  # If the offspring is not NA, return it (with parent itself)
  } else if (!is.na(offspring)) {
    return(c(x, offspring))
  # If the offspring is NA, return the GO term itself wrapped in a list
  } else {
    return(x)
  }
})
names(parent2child_list) <- ub_parent_terms

#2 Build DB with Category > Parent > Children
ub_db <- list(
  ubiquitination = list(
    `GO:0016567` = parent2child_list[["GO:0016567"]],
    `GO:0006511` = parent2child_list[["GO:0006511"]],
    `GO:0010992` = parent2child_list[["GO:0010992"]],
    `GO:0070086` = parent2child_list[["GO:0070086"]],
    `GO:0120323` = parent2child_list[["GO:0120323"]],
    `GO:0031398` = parent2child_list[["GO:0031398"]],
    `GO:2000060` = parent2child_list[["GO:2000060"]]
  ),
  deubiquitination = list(
    `GO:0016579` = parent2child_list[["GO:0016579"]],
    `GO:0031397` = parent2child_list[["GO:0031397"]],
    `GO:2000059` = parent2child_list[["GO:2000059"]]
  ),
  ubiquitin_independent = list(
    `GO:0010499` = parent2child_list[["GO:0010499"]]
  )
)

#3 Get all GO terms related to ubiquitin and filter for BP
ubiquitin_terms <- searchGOTerms("ubiquitin")
ub_godb_bp_df <- ubiquitin_terms %>% 
  dplyr::filter(go_category == "BP") %>% 
  dplyr::select(go_id, go_term, go_category) %>% 
  dplyr::distinct()

# Data.frame that maps go_parent_id to go_parent_term
go_parent_term_mapping <- ub_godb_bp_df %>% 
  dplyr::select(go_id, go_term) %>% 
  dplyr::filter(go_id %in% ub_parent_terms) %>% 
  dplyr::rename(go_parent_id = go_id,
                go_parent_term = go_term)
rownames(go_parent_term_mapping) <- NULL

#4 Make a data.frame with ensembl_id, go_category, category, go_parent_id, go_parent_term, go_id, go_term

# Query the database to find GO terms associated to each gene
go_ubgenes_result <- queryMany(ub_ensembl_ids,
                 scopes='ensembl.gene', 
                 fields=c('ensembl.gene', 'name', 'summary', 'go', 'pfam'), 
                 species='human', 
                 return.as='DataFrame')

# Filter result for BP
go_ubgenes_bp_res <- go_ubgenes_result$go.BP # Filter for BP only
names(go_ubgenes_bp_res) <- ub_ensembl_ids # Set names

# Convert to data.frame each element of the list
go_ubgenes_bp_list <- lapply(go_ubgenes_bp_res, 
                             function(df) 
                               if (is.null(df)) data.frame(id = character(),
                                                           gocategory = character(), 
                                                           term = character()) 
                               else df %>% 
                                as.data.frame())
# Wrangle the data.frame
go_ubgenes_bp_list <- lapply(go_ubgenes_bp_list,
                             function(x) 
                               x %>% 
                                dplyr::rename(go_id = id,
                                              go_term = term,
                                              go_category = gocategory) %>% 
                                dplyr::select(go_category,
                                              go_id,
                                              go_term))
# Convert list of df to single data.frame
raw_ub_glist_go_bp_df <- bind_rows(go_ubgenes_bp_list, .id = "ensembl_id") %>%
  dplyr::distinct()

# Here I lose 28 genes because GO annotation failed. Collect them for exploration.
empty_dfs <- sapply(go_ubgenes_bp_list, function(x) dim(x)[1] == 0)
lost_genes <- ub_ensembl_ids[empty_dfs]

# Recover some using BiomaRt with grch37
# Connect to the GO BioMart database
ensembl = biomaRt::useMart(biomart="ENSEMBL_MART_ENSEMBL",
                  host="https://grch37.ensembl.org",
                  path="/biomart/martservice",
                  dataset="hsapiens_gene_ensembl")

# Retrieve GO & Ensembl gene ids
ensembl2go_biomart_res <- biomaRt::getBM(attributes = c("namespace_1003",
                                                        "name_1006",
                                                        "go_id",
                                                        "ensembl_gene_id"),
                   filters = "ensembl_gene_id",
                   values = lost_genes,
                   mart = ensembl)

# Filter for biological_process
ensembl2go_bp_res <- ensembl2go_biomart_res %>%
  dplyr::rename(go_category = namespace_1003,
                go_term = name_1006,
                ensembl_id = ensembl_gene_id) %>%
  dplyr::filter(go_category == "biological_process") %>%
  dplyr::mutate(go_category = ifelse(go_category == "biological_process", "BP", go_category)) %>% 
  dplyr::distinct() %>% 
  dplyr::select(ensembl_id, go_category, go_id, go_term) # Re-arrange

# Append to raw_ub_glist_go_bp_df
raw_ub_glist_go_bp_df <- bind_rows(raw_ub_glist_go_bp_df, ensembl2go_bp_res)

# Here I lose 19 genes because GO annotation failed. Recovered 9 using grch37. Collect them for exploration.
lost_genes2 <- setdiff(ub_ensembl_ids, raw_ub_glist_go_bp_df$ensembl_id)

#5 Annotate using PFAM where possible
# Get PFAM for lost_genes2
# Filter result for pfam
pfam_ubgenes <- go_ubgenes_result$pfam
names(pfam_ubgenes) <- ub_ensembl_ids # Set names

# Find pfam for lost_genes2
pfam_lost_genes <- pfam_ubgenes[names(pfam_ubgenes) %in% lost_genes2]

# Remove the ones that have NULL and collect for manual annotation.
# Identify NULL elements
null_elements <- sapply(pfam_lost_genes, is.null)

# Remove NULL elements from pfam_lost_genes
pfam_lost_genes <- pfam_lost_genes[!null_elements]

# Convert to df
pfam_ubgenes_df <- pfam_ubgenes %>% 
  tibble::enframe(name = "ensembl_id", value = "pfam") %>% 
  tidyr::unnest(pfam) %>% 
  dplyr::distinct()

pfam_lost_genes_df <- pfam_lost_genes %>% 
  tibble::enframe(name = "ensembl_id", value = "pfam") %>% 
  tidyr::unnest(pfam) %>% 
  dplyr::distinct()

# Check if another annotated gene has the same PFAM domain and annotate it
# Perform an inner join on the pfam column
shared_pfam_df <- pfam_lost_genes_df %>%
  dplyr::inner_join(pfam_ubgenes_df, by = "pfam", suffix = c("_lost", "_ub")) %>%
  # Filter out rows where ensembl_id matches between the two dataframes
  dplyr::filter(ensembl_id_lost != ensembl_id_ub)

# Query PFAM domains to get GO terms
query_pfam <- unique(pfam_lost_genes_df$pfam)

pfam_ubgenes_result <- queryMany(query_pfam,
                 scopes='pfam', 
                 fields=c('ensembl.gene', 'name', 'go', 'pfam'), 
                 species='human', 
                 return.as='DataFrame')

# Filter result for BP
pfam_ubgenes_bp_res <- pfam_ubgenes_result$go.BP # Filter for BP only
query_names <- pfam_ubgenes_result$query
query_ensembl <- pfam_ubgenes_result$ensembl

# Set names
names(pfam_ubgenes_bp_res) <- query_names
names(query_ensembl) <- query_names

# Convert to data.frame each element of the list
pfam_ubgenes_bp_list <- lapply(pfam_ubgenes_bp_res, 
                             function(df) 
                               if (is.null(df)) data.frame(id = character(),
                                                           gocategory = character(), 
                                                           term = character()) 
                               else df %>% 
                                as.data.frame())
# Wrangle the data.frame
pfam_ubgenes_bp_list <- lapply(pfam_ubgenes_bp_list,
                             function(x) 
                               x %>% 
                                dplyr::rename(go_id = id,
                                              go_term = term,
                                              go_category = gocategory) %>% 
                                dplyr::select(go_category,
                                              go_id,
                                              go_term))

pfam_ubgenes_bp_list_with_ensembl <- lapply(names(pfam_ubgenes_bp_list), function(name) {
  # Extract the corresponding dataframe
  df <- pfam_ubgenes_bp_list[[name]]
  
  # Extract the corresponding ensembl_id, ensure it's not a list but a single value or a vector of the same value
  ensembl_id <- rep(query_ensembl[name], ifelse(is.null(df), 1, nrow(df)))
  
  # Handle the case where the dataframe is NULL or empty
  if(is.null(df) || nrow(df) == 0) {
    # Create a dataframe with a single row indicating NA entries except for the ensembl_id
    df <- data.frame(go_id = NA, go_category = NA, go_term = NA, stringsAsFactors = FALSE)
    n <- length(ensembl_id) # Ensure there's at least one row for the ensembl_id
    df <- df[rep(1, n), ]
  }
  
  # Assign the ensembl_id(s)
  df$ensembl_id <- ensembl_id
  
  df
})

# Set names again
names(pfam_ubgenes_bp_list_with_ensembl) <- query_names

# Ensure every dataframe in the list has columns of the correct type, handling empty dataframes explicitly
pfam_ubgenes_bp_list_standardized <- purrr::map(pfam_ubgenes_bp_list_with_ensembl, function(df) {
  if(nrow(df) == 0) { # Check if the dataframe is empty
    # Explicitly define the dataframe with the correct types for each column
    df <- data.frame(go_id = character(), 
                     go_category = character(), 
                     go_term = character(), 
                     ensembl_id = character(), 
                     stringsAsFactors = FALSE)
  } else {
    # For non-empty dataframes, ensure all columns are of type character
    df$go_id <- as.character(df$go_id)
    df$go_category <- as.character(df$go_category)
    df$go_term <- as.character(df$go_term)
    df$ensembl_id <- as.character(unlist(df$ensembl_id))
  }
  df
})

# Now combine the standardized list of dataframes into a single dataframe
pfam2go_res_df <- bind_rows(pfam_ubgenes_bp_list_standardized, .id = "pfam") %>%
  dplyr::distinct() %>% 
  dplyr::rename(ensembl_id_ub = ensembl_id)

# Map pfam2go_res_df to shared_pfam_df by ensembl_id_ub
found_pfam_df <- pfam2go_res_df %>%
  dplyr::inner_join(shared_pfam_df, by = c("ensembl_id_ub", "pfam")) %>%
  # Filter out rows where ensembl_id matches between the two dataframes
  dplyr::filter(ensembl_id_lost != ensembl_id_ub)

# Arrange df to merge with raw_ub_glist_go_bp_df
merge_pfam2go <- found_pfam_df %>% 
  dplyr::select(ensembl_id_lost, go_category, go_id, go_term) %>% 
  dplyr::rename(ensembl_id = ensembl_id_lost)

# Merge with previous df
raw_ub_glist_go_bp_df <- bind_rows(raw_ub_glist_go_bp_df, merge_pfam2go) %>% 
  dplyr::distinct()

# Collect not annotated genes for manual annotation.
lost_genes3 <- setdiff(ub_ensembl_ids, raw_ub_glist_go_bp_df$ensembl_id)

# Here, I still have 14 genes for which I don't have GO term.

################### REMOVE SOME GENES FROM BELOW THAT HAVE BEEN ANNOTATED WITH PFAM

# Manually annotate the remaining 14 genes.
manual_annot_df <- data.frame(
  ensembl_id = lost_genes3,
  go_id = rep("", length(lost_genes3)),
  go_category = rep("BP", length(lost_genes3)),
  go_term = rep("", length(lost_genes3)),
  stringsAsFactors = FALSE
)
manual_annot_df <- manual_annot_df %>%
  dplyr::mutate(
    go_id = case_when(
      ensembl_id == "ENSG00000131982" ~ "",
      ensembl_id == "ENSG00000267741" ~ "",
      ensembl_id == "ENSG00000198354" ~ "",
      ensembl_id == "ENSG00000226372" ~ "",
      ensembl_id == "ENSG00000189186" ~ "",
      ensembl_id == "ENSG00000164616" ~ "",
      ensembl_id == "ENSG00000187954" ~ "",
      ensembl_id == "ENSG00000254726" ~ "",
      ensembl_id == "ENSG00000238222" ~ "",
      ensembl_id == "ENSG00000165966" ~ "",
      ensembl_id == "ENSG00000010318" ~ "",
      ensembl_id == "ENSG00000167257" ~ "",
      ensembl_id == "ENSG00000189051" ~ "",
      ensembl_id == "ENSG00000233198" ~ "",
      ensembl_id == "ENSG00000101236" ~ "",
      ensembl_id == "ENSG00000105982" ~ "",
      ensembl_id == "ENSG00000155890" ~ "",
      ensembl_id == "ENSG00000034063" ~ "",
      ensembl_id == "ENSG00000251694" ~ "",
      TRUE ~ go_id  # Keeps existing value if no condition is matched
    ),
    go_term = case_when(
      ensembl_id == "ENSG00000131982" ~ "",
      ensembl_id == "ENSG00000267741" ~ "",
      ensembl_id == "ENSG00000198354" ~ "",
      ensembl_id == "ENSG00000226372" ~ "",
      ensembl_id == "ENSG00000189186" ~ "",
      ensembl_id == "ENSG00000164616" ~ "",
      ensembl_id == "ENSG00000187954" ~ "",
      ensembl_id == "ENSG00000254726" ~ "",
      ensembl_id == "ENSG00000238222" ~ "",
      ensembl_id == "ENSG00000165966" ~ "",
      ensembl_id == "ENSG00000010318" ~ "",
      ensembl_id == "ENSG00000167257" ~ "",
      ensembl_id == "ENSG00000189051" ~ "",
      ensembl_id == "ENSG00000233198" ~ "",
      ensembl_id == "ENSG00000101236" ~ "",
      ensembl_id == "ENSG00000105982" ~ "",
      ensembl_id == "ENSG00000155890" ~ "",
      ensembl_id == "ENSG00000034063" ~ "",
      ensembl_id == "ENSG00000251694" ~ "",
      TRUE ~ go_term
    )
  )




# Initialize an empty list to hold the mapping
go_mapping <- list()

# Iterate through each category in ub_db
for (category in names(ub_db)) {
  # Iterate through each parent within a category
  for (parent_id in names(ub_db[[category]])) {
    # Iterate through each child within a parent
    children_ids <- ub_db[[category]][[parent_id]]
    for (child_id in children_ids) {
      # Append the category and parent information to the mapping list for each child
      if (!is.null(go_mapping[[child_id]])) {
        go_mapping[[child_id]] <- unique(c(go_mapping[[child_id]], paste(parent_id, category, sep = "|")))
      } else {
        go_mapping[[child_id]] <- paste(parent_id, category, sep = "|")
      }
    }
  }
}

# Convert the mapping list to a data.frame for easier manipulation
go_mapping_df <- stack(go_mapping)
names(go_mapping_df) <- c("info", "go_id")

# Split info into go_parent_id and category
go_mapping_df <- go_mapping_df %>%
  tidyr::separate(info, into = c("go_parent_id", "category"), sep = "\\|")

# Join the mapping information back to the original data.frame
final_df <- raw_ub_glist_go_bp_df %>%
  left_join(go_mapping_df, by = "go_id")

# Handle cases where a child belongs to multiple parents
final_df <- final_df %>%
  group_by(ensembl_id, go_category, go_id, go_term) %>%
  summarise(go_parent_id = paste(unique(go_parent_id), collapse = ", "),
            category = paste(unique(category), collapse = ", "),
            .groups = 'drop')

# Arrange columns in the desired order
final_df <- final_df %>%
  dplyr::select(ensembl_id, go_category, category, go_parent_id, go_term, go_id)

# Converting NAs and ordering columns
annot_ub_glist_df <- final_df %>% 
  dplyr::mutate(across(everything(), ~na_if(.x, "NA"))) %>% 
  dplyr::select(ensembl_id, 
                go_category, 
                category, 
                go_parent_id, 
                go_id, 
                go_term)

# Amend those that have multiple values in category and go_parent_id
annot_ub_glist_df <- annot_ub_glist_df %>%
  dplyr::mutate(
    # Check if 'category' contains multiple values and update accordingly
    category = ifelse(grepl(",", category) & 
                      (grepl("deubiquitination", go_term) | grepl("negative regulation", go_term) & grepl("ubiquitin", go_term)),
                      "deubiquitination",
                      ifelse(grepl(",", category) & 
                             (grepl("ubiquitination", go_term) & !grepl("deubiquitination", go_term) | grepl("positive regulation", go_term) & grepl("ubiquitin", go_term)),
                             "ubiquitination",
                             category)),
    # Check if 'go_parent_id' contains multiple values and update accordingly
    go_parent_id = ifelse(grepl(",", go_parent_id) & grepl("GO:0016579", go_parent_id),
                          "GO:0016579",
                          ifelse(grepl(",", go_parent_id) & grepl("GO:2000059", go_parent_id),
                                 "GO:2000059",
                                 ifelse(grepl(",", go_parent_id) & grepl("GO:0031397", go_parent_id),
                                        "GO:0031397",
                                        ifelse(grepl(",", go_parent_id) & grepl("GO:0031398", go_parent_id),
                                               "GO:0031398",
                                               ifelse(grepl(",", go_parent_id) & grepl("GO:2000060", go_parent_id),
                                               "GO:2000060",
                                               go_parent_id)))))
  )

# DEBUG: check category
# rows_with_multiple_categories <- annot_ub_glist_df %>%
#   dplyr::filter(grepl(",", category))

# DEBUG: check go_parent_id
# rows_with_multiple_parents <- annot_ub_glist_df %>%
#   dplyr::filter(grepl(",", go_parent_id))

# Adding go_parent_term
annot_ub_glist_df <- annot_ub_glist_df %>%
  left_join(go_parent_term_mapping, by = "go_parent_id")

# Identify genes that don't have a parent
ensembl_ids_all_na_category <- annot_ub_glist_df %>%
  dplyr::group_by(ensembl_id) %>%
  dplyr::summarize(all_na_in_category = all(is.na(category)), .groups = 'drop') %>%
  dplyr::filter(all_na_in_category) %>%
  dplyr::pull(ensembl_id)

final_df_filtered_all_na <- annot_ub_glist_df %>%
  filter(ensembl_id %in% ensembl_ids_all_na_category)

# Here I lose 86 genes because no parent was found. Collect them for exploration.
lost_genes4 <- final_df_filtered_all_na %>% 
  dplyr::distinct(ensembl_id) %>% 
  dplyr::pull(ensembl_id)

ensembl_ids_with_non_na_category <- annot_ub_glist_df %>%
  dplyr::group_by(ensembl_id) %>%
  dplyr::summarize(any_non_na_in_category = any(!is.na(category)), .groups = 'drop') %>%
  dplyr::filter(any_non_na_in_category) %>%
  dplyr::pull(ensembl_id)

final_df_filtered_non_na <- annot_ub_glist_df %>%
  filter(ensembl_id %in% ensembl_ids_with_non_na_category)
  
# 560/674 genes remaining. 114 genes lost in total. Here I used GRCh38

###############################################################################

# ### Alternative: use BiomaRt with grch37
# # Get all GO terms for the ub genes using biomaRt
# # Connect to the GO BioMart database
# ensembl = biomaRt::useMart(biomart="ENSEMBL_MART_ENSEMBL", 
#                   host="https://grch37.ensembl.org", 
#                   path="/biomart/martservice",
#                   dataset="hsapiens_gene_ensembl")
# 
# # Retrieve GO & Ensembl gene ids
# ensembl2go_biomart_res <- biomaRt::getBM(attributes = c("namespace_1003",
#                                                         "name_1006",
#                                                         "go_id", 
#                                                         "ensembl_gene_id"),
#                    filters = "ensembl_gene_id",
#                    values = ub_ensembl_ids,
#                    mart = ensembl)
# 
# # Filter for biological_process
# ensembl2go_bp_res <- ensembl2go_biomart_res %>% 
#   dplyr::rename(go_category = namespace_1003,
#                 go_term = name_1006,
#                 ensembl_id = ensembl_gene_id) %>% 
#   dplyr::filter(go_category == "biological_process") %>% 
#   dplyr::distinct()
# 
# # ensembl2go_bp_res %>% 
# #   dplyr::select(ensembl_gene_id) %>% 
# #   dplyr::distinct()
# 
# # Here I lose 120 genes because GO annotation failed. Collect them for exploration.
# lost_genes3 <- setdiff(ub_ensembl_ids, ensembl2go_bp_res$ensembl_id)
# 
# # Join the mapping information back to the original data.frame
# final_df2 <- ensembl2go_bp_res %>%
#   left_join(go_mapping_df, by = "go_id")
# 
# # Handle cases where a child belongs to multiple parents
# final_df2 <- final_df2 %>%
#   group_by(ensembl_id, go_category, go_id, go_term) %>%
#   summarise(go_parent_id = paste(unique(go_parent_id), collapse = ", "),
#             category = paste(unique(category), collapse = ", "),
#             .groups = 'drop')
# 
# # Arrange columns in the desired order
# final_df2 <- final_df2 %>%
#   dplyr::select(ensembl_id, go_category, category, go_parent_id, go_term, go_id)
# 
# # Adding go_parent_term
# final_df2 <- final_df2 %>%
#   left_join(go_parent_term_mapping, by = "go_parent_id")
# 
# # Converting NAs and ordering columns
# annot_ub_glist_df2 <- final_df2 %>% 
#   mutate(across(everything(), ~na_if(.x, "NA"))) %>% 
#   dplyr::select(ensembl_id, 
#                 go_category, 
#                 category, 
#                 go_parent_id, 
#                 go_parent_term, 
#                 go_id, 
#                 go_term)
# 
# # Identify genes that don't have a parent
# ensembl_ids_all_na_category2 <- annot_ub_glist_df2 %>%
#   dplyr::group_by(ensembl_id) %>%
#   dplyr::summarize(all_na_in_category = all(is.na(category)), .groups = 'drop') %>%
#   dplyr::filter(all_na_in_category) %>%
#   dplyr::pull(ensembl_id)
# 
# final_df_filtered_all_na2 <- annot_ub_glist_df2 %>%
#   filter(ensembl_id %in% ensembl_ids_all_na_category2)
# 
# # Here I lose 154 genes because no parent was found. Collect them for exploration.
# lost_genes4 <- final_df_filtered_all_na2 %>% 
#   dplyr::distinct(ensembl_id) %>% 
#   dplyr::pull(ensembl_id)
# 
# ensembl_ids_with_non_na_category2 <- annot_ub_glist_df2 %>%
#   dplyr::group_by(ensembl_id) %>%
#   dplyr::summarize(any_non_na_in_category = any(!is.na(category)), .groups = 'drop') %>%
#   dplyr::filter(any_non_na_in_category) %>%
#   dplyr::pull(ensembl_id)
# 
# final_df_filtered_non_na2 <- annot_ub_glist_df2 %>%
#   filter(ensembl_id %in% ensembl_ids_with_non_na_category2)

# 400/674 genes remaining. 274 genes lost in total. Here I used GRCh37

###############################################################################

# Remove unannotated GO terms (unrelated to ubiquitin)
final_ub_db <- annot_ub_glist_df %>% 
  dplyr::filter(!is.na(go_parent_id)) %>% 
  dplyr::distinct()

# Count how many genes each category has
final_category_gene_count <- final_ub_db %>% 
  dplyr::group_by(category) %>%
  dplyr::summarise(ensembl_id_count = n_distinct(ensembl_id)) %>%
  dplyr::arrange(desc(ensembl_id_count))

# Count how many genes each parent has
final_parent_gene_count <- final_ub_db %>% 
  dplyr::group_by(go_parent_id, go_parent_term) %>%
  dplyr::summarise(ensembl_id_count = n_distinct(ensembl_id)) %>%
  dplyr::arrange(desc(ensembl_id_count))

# Display
datatable(final_category_gene_count, 
          extensions = c('Buttons', 
                         'FixedColumns'), 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            fixedColumns = list(leftColumns = 1), # Freeze the first column
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "Count of genes included in each ubiquitin category."
        )

datatable(final_parent_gene_count, 
          extensions = c('Buttons', 
                         'FixedColumns'), 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            fixedColumns = list(leftColumns = 1), # Freeze the first column
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "Count of genes included in each ubiquitin go parent term."
        )

#5 Annotate Ensembl Gene IDs to each parent go term to do FORA
# Query the database to find Ensembl IDs for each GO term
go2ensembl_result <- queryMany(ub_parent_terms,
                 scopes='go', 
                 fields=c('ensembl.gene', 'name', 'go'), 
                 species='human', 
                 return.as='DataFrame')

# Filter result for ensembl
go2ensembl_names <- go2ensembl_result$query
go2ensembl_filtered <- go2ensembl_result$ensembl
names(go2ensembl_filtered) <- go2ensembl_names # Set names

# Convert to data.frame each element of the list
go2ensembl_list <- lapply(go2ensembl_filtered, 
                             function(df) 
                               if (is.null(df)) data.frame(gene = character()) 
                               else df %>% 
                                as.data.frame())
# Wrangle the data.frame
go2ensembl_list <- lapply(go2ensembl_list,
                             function(x) 
                               x %>% 
                                dplyr::rename(ensembl_id = gene) %>% 
                                dplyr::select(ensembl_id))
# Convert list of df to single data.frame
raw_go2ensembl_df <- bind_rows(go2ensembl_list, .id = "go_parent_id") %>%
  dplyr::distinct()

# Adding go_parent_term
raw_go2ensembl_df <- raw_go2ensembl_df %>%
  left_join(go_parent_term_mapping, by = "go_parent_id")

#6 Perform FORA analysis
# Define paths
fora_results_all_csv_path <- file.path(results_ubgenesets_path, "fora_results_ubiquitin_all.csv")
fora_results_nonsyn_csv_path <- file.path(results_ubgenesets_path, "fora_results_ubiquitin_nonsyn.csv")
fora_results_lof_csv_path <- file.path(results_ubgenesets_path, "fora_results_ubiquitin_lof.csv")

# Adapt structure to gene_sets_list
gene_sets_df <- raw_go2ensembl_df %>% 
  dplyr::group_by(go_parent_term) %>%
  dplyr::summarise(ensembl_ids = list(unique(ensembl_id)), .groups = 'drop')

# Convert the dataframe to a named list
gene_sets_list <- setNames(gene_sets_df$ensembl_ids, gene_sets_df$go_parent_term)

# Perform FORA analysis for Ubiquitin Gene Sets
# perform_fora_analysis(sample_id_list, list_of_all_ub_mutations, list_of_nonsyn_ub_mutations, list_of_lof_ub_mutations, fora_results_all_csv_path, fora_results_nonsyn_csv_path, fora_results_lof_csv_path, gene_sets_list=gene_sets_list)

# Load fora results
fora_results_ubiquitin_all_df <- read.csv(fora_results_all_csv_path, header = TRUE)[ , -1]
fora_results_ubiquitin_nonsyn_df <- read.csv(fora_results_nonsyn_csv_path, header = TRUE)[ , -1]
fora_results_ubiquitin_lof_df <- read.csv(fora_results_lof_csv_path, header = TRUE)[ , -1]
```

There are `r length(ub_ensembl_ids)` mutated ubiquitin-related genes in total.

There are `r nrow(ub_godb_bp_df)` GO BP terms related to ubiquitin in total (from GO.db). Filter using grep("ubiquitin").

This is my selected GO terms related to ubiquitin to build the Gene Sets DB: `r ub_parent_terms`.

The resulting data.frame with annotated go_terms has more rows than the initial ubiquitin gene list because a single gene can be part of multiple GO terms (BP).

When I annotate the genes with GO terms, I lose some genes: `r nrow(raw_ub_glist_go_bp_df %>% dplyr::select(ensembl_id) %>% distinct())` vs `r length(ub_ensembl_ids)` (lost `r length(lost_genes)` genes). This is because no GO term was associated to these genes.

Seeing this, I had a look at some of the genes that were lost. I saw that for most of them, no GO annotation could be found. However, for some I could see that grch37 had a GO annotation while grch38 didn't. The ones that had annotation for GO BP in grch37 were related to proteolysis (ENSG00000154359, ENSG00000170500, ENSG00000175556), apoptotic regulation (ENSG00000163098, ENSG00000056661), autoubiquitination (ENSG00000121848), ubiquitin-dependent protein catabolic process (ENSG00000242013, ENSG00000166348, ENSG00000161133). I annotated them using biomaRt.

That led me to have `r length(lost_genes2)` missing genes. So, I tried extracting the PFAM for those genes and then annotating the PFAM with GO BP terms and Ensembl Gene IDs. Then I mapped this results to the missing genes by PFAM, assuming that those genes which share PFAM domain will be involved in the same biological process. Now I have some of the missing genes with GO terms based on their PFAM.

After that I still had `r length(lost_genes3)` missing genes that I annotated manually.

So I did a test: annotate with biomaRt instead of mygene and check how many genes were not annotated then. Unfortunately, even more genes were lost. In conclusion, it is better to annotate GO terms using the grch38 assembly.

Later I handled those cases that had multiple categories (i.e. ubiquitination and deubiquitination) and multiple parent ids. This happens because the negative regulation processes have "protein ubiquitination" as a parent GO term, so I removed the ubiquitin category and related parent terms from those ensembl ids. It also happens that positive regulation processes have "protein ubiquitination" as parent GO term, so I handled those as well.

When I annotate genes with parent GO terms, I lose `r length(lost_genes4)` genes because no GO parent was found. I checked some of them and they don't seem to have relationship with ubiquitin processes. They are involved in other important processes such as DNA repair, apoptotic regulation, etc.

## Visualization: Top Custom Ubiquitin GS across samples stratified by response (All mutations)

```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
# Define output path
mm909_ubiquitin_all_plot_path <- file.path(figures_ubgenesets_path,
                              "mm909_ubiquitin_all_plot.png")

mm909_ubiquitin_all_plot <- plot_top5(response_df, fora_results_ubiquitin_all_df, mm909_ubiquitin_all_plot_path, "FORA with top Custom Ubiquitin GS across samples (All mutations)", "Top Ubiquitin Gene Sets")

print(mm909_ubiquitin_all_plot)
```

### Visualization: Top Custom Ubiquitin GS across samples stratified by response (Nonsyn mutations)

```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
# Define output path
mm909_ubiquitin_nonsyn_plot_path <- file.path(figures_ubgenesets_path,
                              "mm909_ubiquitin_nonsyn_plot.png")

mm909_ubiquitin_nonsyn_plot <- plot_top5(response_df, fora_results_ubiquitin_nonsyn_df, mm909_ubiquitin_nonsyn_plot_path, "FORA with top Custom Ubiquitin GS across samples (Nonsyn mutations)", "Top Ubiquitin Gene Sets")

print(mm909_ubiquitin_nonsyn_plot)
```

### Visualization: Top Custom Ubiquitin GS across samples stratified by response (LoF mutations)

```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=6}
# Define output path
mm909_ubiquitin_lof_plot_path <- file.path(figures_ubgenesets_path,
                              "mm909_ubiquitin_lof_plot.png")

mm909_ubiquitin_lof_plot <- plot_top5(response_df, fora_results_ubiquitin_lof_df, mm909_ubiquitin_lof_plot_path, "FORA with top Custom Ubiquitin GS across samples (LoF mutations)", "Top Ubiquitin Gene Sets")

print(mm909_ubiquitin_lof_plot)
```

## Visualization: Box plot per 10 Gene Sets

This does not have the filter p.adjust < 0.05.

```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# Calculate the sequence of indices in steps of 10
indices <- seq(from = 1, to = length(gene_sets_list), by = 6)

# Loop through the indices
global_idx <- 1
for (i in indices) {
  # Select a group of 10 gene sets or the remaining ones if less than 10
  geneset_group <- names(gene_sets_list)[i:min(i+9, length(gene_sets_list))]
  
  # Define the output plot path dynamically based on the current index
  plot_path <- file.path(figures_ubgenesets_path, paste0(global_idx, "_combinedGS_lof_boxplot.png"))
  
  # Call the plotting function with the current geneset group
  combinedGS_lof_plot <- boxplot_genesets(geneset_group, response_df, fora_results_ubiquitin_lof_df, plot_path, 
                                      paste("FORA with GS", i, "to", min(i+9, length(gene_sets_list)), 
                                            "stratified by response (LoF mutations)"), 3)
  
  # Print
  print(combinedGS_lof_plot)
  
  # Update global index
  global_idx = global_idx + 1
}
```

## Visualization: Global heat map

This does not have the filter p.adjust < 0.05.

```{r, warning=FALSE, message=FALSE, fig.width=10, fig.height=10}
plot_path <- file.path(figures_ubgenesets_path, "mm909_combinedGS_lof_heat_map.png")
combinedGS_lof_plot <- heat_map_genesets(response_df, fora_results_ubiquitin_lof_df, plot_path, 
                                    "Heat Map of combined Gene Sets per patient")

# Print
print(combinedGS_lof_plot)
```

### Visualization: Bubble plot per Gene Set

This does not have the filter p.adjust < 0.05.

```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=5}
# Loop through each geneset
for(geneset in names(gene_sets_list)) {
  # Define the output plot path dynamically based on the current geneset
  plot_path <- file.path(figures_ubgenesets_path, paste0(geneset, "_combinedGS_lof_bubbleplot.png"))
  
  # Generate the plot title dynamically
  plot_title <- paste("FORA with", geneset, "GS per sample stratified by response (LoF mutations)")
  y_label <- NULL
  
  # Use tryCatch when calling the plotting function
  tryCatch({
    # Attempt to generate and print the plot
    combinedGS_lof_plot <- plot_geneset(geneset, response_df, fora_results_ubiquitin_lof_df, plot_path, plot_title, y_label)
    print(combinedGS_lof_plot)
  }, error = function(e) {
    # If an error occurs, print the error message
    cat("An error occurred with geneset", geneset, ": ", e$message, "\n")
  })
}
```

# Create a binary matrix (LoF - Ubiquitin)

This binary matrix has ubiquitin mutated genes as rows and patients as columns. There is a 1 if a particular gene was mutated at least once for a specific sample, and zero otherwise.

```{r, message=FALSE, warning=FALSE}
# Create a dataframe for the matrix, initialize with ensembl_id and hugo_symbol, fill 0 for samples
lof_ub_binary <- data.frame(ensembl_id = ub_ensembl_ids, hugo_symbol = rep(NA, length(ub_ensembl_ids)))

# For each sample_id, add a column to lof_ub_binary and initialize with 0
for (sample_id in unique(lof_df_ubiquitin$sample_id)) {
  lof_ub_binary[[sample_id]] <- 0
}

# Map hugo_symbols to the corresponding ensembl_id
hugo_map <- lof_df_ubiquitin[!duplicated(lof_df_ubiquitin$ensembl_id), c("ensembl_id", "hugo_symbol")]
lof_ub_binary$hugo_symbol <- hugo_map$hugo_symbol[match(lof_ub_binary$ensembl_id, hugo_map$ensembl_id)]

# Fill the matrix with 1s where appropriate
for (i in 1:nrow(lof_df_ubiquitin)) {
  row <- lof_df_ubiquitin[i, ]
  if (row$ensembl_id %in% lof_ub_binary$ensembl_id) {
    lof_ub_binary[row$ensembl_id == lof_ub_binary$ensembl_id, row$sample_id] <- 1
  }
}

# Annotate missing Hugo Symbols with Ensembl Gene IDs
missing_hsymbols <- is.na(lof_ub_binary$hugo_symbol)
new_hsymbols <- ENSEMBLtoSYMBOL(lof_ub_binary$ensembl_id[missing_hsymbols])
lof_ub_binary$hugo_symbol[missing_hsymbols] <- new_hsymbols

# Save the lof_binary into a file
lof_ub_binary_out_path <- file.path(results_ubgenesets_path, 
                      "lof_ub_binary.csv")
write.csv(lof_ub_binary, file = lof_ub_binary_out_path, row.names = TRUE)

# Display
datatable(lof_ub_binary, 
          extensions = c('Buttons', 
                         'FixedColumns'), 
          options = list(
            dom = 'Bfrtip',
            buttons = c('copy', 'excel', 'csv'),
            scrollX=TRUE,
            pageLength=10,
            fixedColumns = list(leftColumns = 3), # Freeze the first 3 columns
            columnDefs = list(list(
              targets = "_all",
              render = JS(
                "function(data, type, row, meta) {",
                "  return data === null ? 'NA' : data;",
                "}"
              )
            ))
          ),
          caption = "Binary matrix of ubiquitin LoF mutations per sample."
        )
```

# Session Info

```{r}
sessionInfo()
```
